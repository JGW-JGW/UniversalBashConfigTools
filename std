#!/bin/bash
# shellcheck disable=SC2120
function std_strip() {
  echo "$*" | sed -r 's/^[[:space:]]+//' | sed -r 's/[[:space:]]+$//'
  return 0
}

function std_prtmsg() {
  local type="$1"
  local msg="$2"

  case "${type}" in
  DONE | CORRECT)
    echo -e "\e[40;31;1m${type}\e[0m\c"
    ;;
  SKIP)
    echo -e "\e[47;30m${type}\e[0m\c"
    ;;
  ERROR | CHECK)
    echo -e "\e[47;30;5m${type}\e[0m\c"
    ;;
  INFO)
    echo -e "${type}\c"
    ;;
  STDINFO)
    echo -e "---- INFO\c"
    ;;
  STDERR | STDERROR)
    echo -e "---- \e[47;30;5mERROR\e[0m\c"
    ;;
  FUNCBEGIN | FUNCSTART)
    echo -e "======== \e[40;31;1m${FUNCNAME[1]} \e[47;30mSTART\e[0m\c"
    ;;
  FUNCEND)
    echo -e "======== \e[40;31;1m${FUNCNAME[1]} \e[47;30mEND\e[0m\c"
    ;;
  FUNCERR | FUNCERROR)
    echo -e "==== \e[40;31;1m${FUNCNAME[1]} \e[47;30;5mERROR\e[0m\c"
    ;;
  FUNCINFO)
    echo -e "==== \e[40;31;1m${FUNCNAME[1]} \e[0mINFO\c"
    ;;
  *)
    echo -e "ERROR: unknown type: \"${type}\""
    return 1
    ;;
  esac

  [[ -n "${msg}" ]] && echo -e ": ${msg}" || echo

  return 0
}

function std_prtline() {
  local parameters char title len_total

  if ! parameters=$(getopt -o c:t:l: --long char:,title:,length: -n "$0" -- "$@"); then
    return 1
  fi

  char=" "
  title=""
  len_total=32

  eval set -- "${parameters}"

  while true; do
    case "$1" in
    -c | --char)
      char="$2"
      if [[ ${#char} -ne 1 ]]; then
        std_prtmsg STDERR "invalid argument for -c/--char: \"${char}\""
        return 1
      fi
      shift 2
      ;;
    -t | --title)
      title="$2"
      shift 2
      ;;
    -l | --length)
      len_total="$2"
      shift 2
      ;;
    --)
      break
      ;;
    *)
      std_prtmsg STDERR "invalid option: \"$1\""
      return 1
      ;;
    esac
  done

  local len_title=${#title}

  if [[ $((len_total - len_title)) -lt 4 ]]; then
    std_prtmsg STDERR "invalid value: total length should be greater than length of title by at least 4, current len_total = ${len_total}, len_title = ${len_title}"
    return 1
  fi

  if [[ ${len_title} -eq 0 ]]; then
    for ((i = 0; i < len_total; i++)); do
      printf "%s" "${char}"
    done
    printf "\n"
    return 0
  fi

  # reaching here means len_title > 0
  local len_diff len_left len_right

  len_diff=$((len_total - len_title))
  if [[ $((len_diff % 2)) -eq 0 ]]; then
    len_left=$((len_diff / 2))
    len_right=${len_left}
  else
    len_left=$(((len_diff - 1) / 2))
    len_right=$((len_left + 1))
  fi

  for ((i = 0; i < len_left; i++)); do
    [[ ${i} -ne $((len_left - 1)) ]] && printf "%s" "${char}" || printf " "
  done

  printf "%s" "${title}"

  for ((i = 0; i < len_right; i++)); do
    [[ ${i} -ne 0 ]] && printf "%s" "${char}" || printf " "
  done

  printf "\n"

  return 0
}

function std_get_conf() {
  local var="$1"
  local file="$2"
  local line value

  line=$(grep -E "^[[:space:]]*${var}([[:space:]]+|[[:space:]]*=)" "${file}" | tail -1)

  if [[ ${line} =~ '=' ]]; then
    eval echo "$(std_strip "$(echo "${line}" | awk -F= '{print $2}')")"
  else
    eval echo "$(std_strip "$(echo "${line}" | awk '{print $2}')")"
  fi
}

function std_is_there() {
  local judge=$1
  local location=$2
  [[ -z "${judge}" ]] && return 1
  [[ -z "${location}" ]] && return 2
  [[ ! -f "${location}" ]] && return 3
  grep -qE "${judge}" "${location}" && return 0 || return 4
}

function std_cmd_exists() {
  local cmd=$1
  type "${cmd}" 1>/dev/null 2>/dev/null && return 0 || return 1
}

function std_backup_file() {
  local current_time origin_file origin_dirname origin_filename backup_dirname backup_file
  current_time=$(date "+%Y-%m-%d_%H_%M_%S")
  origin_file=$*
  origin_dirname=$(dirname "$*")
  origin_filename=$(basename "$*")
  backup_dirname=/tmp/ubct_backup${origin_dirname}
  backup_file=${backup_dirname}/${origin_filename}.bak.${current_time}

  [[ ! -d ${backup_dirname} ]] && mkdir -p "${backup_dirname}"

  std_prtmsg STDINFO "try to backup a file: \"${origin_file}\""

  if [[ -f ${origin_file} ]]; then
    if [[ -f ${backup_file} ]]; then
      std_prtmsg STDINFO "\"${origin_file}\" ALREADY backup as \"${backup_file}\""
      return 0
    else
      cp -p "${origin_file}" "${backup_file}"
      std_prtmsg STDINFO "\"${origin_file}\" backup as \"${backup_file}\""
      return 0
    fi
  elif [[ -d ${origin_dirname} ]]; then
    echo "# Before backup, \"${origin_file}\" does NOT exist." >"${backup_file}"
    std_prtmsg STDINFO "backup an EMPTY file \"${backup_file}\" since \"${origin_file}\" does NOT exist"
    return 0
  else
    std_prtmsg STDERR "\"${origin_dirname}\" is NOT a directory"
    return 1
  fi
}

function std_backup_dir() {
  local current_time origin_dir
  current_time=$(date "+%Y-%m-%d_%H_%M_%S")
  origin_dir=$(dirname "$*")/$(basename "$*")
  if [[ ! -d ${origin_dir} ]]; then
    std_prtmsg STDERR "\"${origin_dir}\" is NOT a directory"
    return 1
  fi
  local backup_dir base_dir parent_dir
  backup_dir=/tmp/ubct_backup${origin_dir}.${current_time}
  base_dir=$(basename "${origin_dir}")
  parent_dir=$(dirname "${backup_dir}")

  std_prtmsg STDINFO "try to backup a directory: \"${origin_dir}\""

  if [[ ! -e ${backup_dir} ]]; then
    mkdir -p "${parent_dir}"
    cp -frp "${origin_dir}" "${parent_dir}"
    mv "${parent_dir}/${base_dir}" "${backup_dir}"
    std_prtmsg STDINFO "\"${origin_dir}\" backup as \"${backup_dir}\""
    return 0
  elif [[ -d ${backup_dir} ]]; then
    std_prtmsg STDINFO "\"${origin_dir}\" ALREADY backup as \"${backup_dir}\""
    return 0
  else
    std_prtmsg STDERR "\"${backup_dir}\" is NOT a directory"
    return 1
  fi
}

# get value of a specific section inside a config file
# ======================
# [section_A]
# key_1 = 1
# key_2 = 2
# # comment
#
# [section_B]
# var_a a
# var_b b
# [END]
# ======================
# usage: std_get_section_conf section_A filename.conf
# ======================
# omit comments and blank lines, returning:
# key_1 = 1
# key_2 = 2
function std_get_section_conf() {
  local section_name="$1"
  local conf_file="$2"

  sed -n "/^[[:space:]]*\[${section_name}\][[:space:]]*$/,/^[[:space:]]*\[/ {/^[[:space:]]*\[${section_name}\][[:space:]]*$\|^[[:space:]]*\[/!p;}" "${conf_file}" | grep -Ev "^[[:space:]]*$|^[[:space:]]*#.*$"
}

# shellcheck disable=SC2207
function std_fstab_check() {
  local n_fstab fs_list_fstab type_list_fstab fs type_df flag
  fs_list_fstab=($(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" /etc/fstab | awk '{print $2}'))
  type_list_fstab=($(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" /etc/fstab | awk '{print $3}'))
  n_fstab=${#fs_list_fstab[@]}

  flag=0

  for ((i = 0; i < n_fstab; i++)); do
    case ${fs_list_fstab[i]} in
    swap | none | /sys | /sys/* | /proc | /proc/* | /dev | /dev/*)
      continue
      ;;
    esac

    [[ "${fs_list_fstab[i]}" != "/" ]] && fs=${fs_list_fstab[i]%/} || fs=${fs_list_fstab[i]}

    type_df=$(df -Th | grep -E "[[:space:]]+${fs}$" | awk '{print $2}')

    if [[ -z "${type_df}" ]]; then # fs not found in df -Th
      flag=1
      std_prtmsg STDERR "mount point \"${fs}\" NOT found in df -Th"
    elif [[ "${type_list_fstab[i]}" != "${type_df}" ]]; then
      flag=1
      std_prtmsg STDERR "mount point \"${fs}\" has different types in fstab and df command: ${type_list_fstab[i]} VS ${type_df}"
    fi
  done

  return ${flag}
}

function std_size_translate() {
  local input_size="$1"

  if [[ "${input_size}" =~ [0-9]+(MB|M)?$ ]]; then
    input_size=${input_size%M*}
    echo "${input_size%.*}"
    return 0
  elif [[ "${input_size}" =~ [0-9]+(GB|G)$ ]]; then
    input_size=${input_size%G*}
    input_size=$((input_size * 1024))
    echo "${input_size%.*}"
    return 0
  elif [[ "${input_size}" =~ [0-9]+(TB|T)$ ]]; then
    input_size=${input_size%T*}
    input_size=$((input_size * 1048576))
    echo "${input_size%.*}"
    return 0
  elif [[ "${input_size}" =~ [0-9]+(KB|K) ]]; then
    input_size=${input_size%K*}
    input_size=$((input_size / 1024))
    echo "${input_size%.*}"
    return 0
  else
    std_prtmsg STDERR "invalid size: \"${input_size}\""
    return 1
  fi
}

function std_get_pv_free_space() {
  local pv_name="$1"
  std_size_translate "$(parted "${pv_name}" print free | grep "Free Space" | tail -1 | awk '{print $3}')"
}

function std_get_pv_part_num() {
  local pv_name="$1"
  parted "${pv_name}" print | grep -Ec "^[[:space:]]*[0-9]+"
}

function std_generate_fs_type() {
  case ${OS_FULL_NAME} in
  centos-7)
    echo xfs
    return 0
    ;;
  *)
    echo NULL
    return 1
    ;;
  esac
}

function std_get_dev_scheduler() {
  local dev_name="$1"
  local file="/sys/block/${dev_name}/queue/scheduler"
  if std_is_there "\[.+\]" "${file}"; then
    cut -d[ -f2 "${file}" | cut -d] -f1
    return 0
  else
    echo "NULL"
    return 1
  fi
}

function std_check_scheduler_status() {
  local scheduler
  case ${OS_FULL_NAME} in
  centos-7)
    for dev in $(lsblk -S | awk '/^sd/ {print $1}'); do
      scheduler=$(std_get_dev_scheduler ${dev})
      if [[ ${dev} == sda && ${scheduler} != cfq ]]; then
        std_prtmsg STDERR "scheduler unfitted: device=\"${dev}\", required=\"cfq\", current=\"${scheduler}"
        return 1
      elif [[ ${dev} != sda && ${scheduler} != none ]]; then
        std_prtmsg STDERR "scheduler unfitted: device=\"${dev}\", required=\"none\", current=\"${scheduler}"
        return 2
      fi
    done
    return 0
    ;;
  *)
    std_prtmsg STDERR "unsupported os: \"${OS_FULL_NAME}\""
    return 3
    ;;
  esac
}

# check whether a fs exists by its mount point
function std_fs_check() {

}
